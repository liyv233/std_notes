# 树



**树的基本概念：**

- 叶子/终端结点：度为0的结点
- 度：结点拥有的子树数目
- 树的度：各个结点中度的最大值
- 树的深度：树中结点的最大层次,从根节点开始算，从0开始计数
- 树的高度：从最下面的叶子结点开始算，从 0 开始计数
- 树的层数：从根节点为第一层开始计算
- 父节点：含有子节点的结点，称为其子节点的父节点
- 子节点：含有父节点的结点，称为其父节点的子节点
- 兄弟结点：具有相同父节点的节点互为兄弟结点
- 结点的高度：该节点到叶子节点的最长路径所包含的边数
- 结点的深度：根节点到该节点的路径所包含的边数
- 结点的层数：结点的深度+1



**树的基本特点：**

- 一棵树中的任意两个结点有且仅有唯一的一条路径连通
- 一棵树如果有 n 个结点，那么它一定恰好有 n-1 条边
- 一棵树不包含回路





# 二叉树



**定义：**每个结点的度不大于2且有左右之分的树

**性质：**

- 第 i 层至多拥有 `2^(i-1)` 个节点
- 深度为 k 的二叉树至多总共有 `2^(k+1)-1` 个节点（满二叉树的情况，等比数列的求和），至少有 2^(k) 个节点
- 对任意一颗二叉树，如果其叶子结点数量为：n0, 度为2的结点数为：n2，则：**n0=n2+1**
- 二叉树有n个结点，m 条边 ： **n = m + 1** ， n = n0 + n1 + n2
- 有等式 n1+2*n2+1=n1+n0+n2 成立 ， 即 n1+2*n2 + 1 = m - 1
- 具有n个结点的完全二叉树的深度 k 为：**k = [log2n]+1**，其中[log2n]+1是向下取整



## 二叉树的存储结构

### 顺序存储

顺序存储就是利用数组进行存储，数组中的每一个位置仅存储节点的 data，不存储左右子节点的指针

一般顺序存储结构是拿来存储完全二叉树的，但是也可以拿来存储一般的二叉树，只是要按照完全二叉树的规则来编号，如果没有的就存 标识符

根结点的序号为 1，对于每个节点 Node，假设它存储在数组中下标为 i 的位置，那么它的左子节点就存储在 2i 的位置，它的右子节点存储在下标为 2i+1 的位置。

存储的二叉树不是完全二叉树，在数组中就会出现空隙，导致内存利用率降低



有**N个结点的完全二叉树**各结点如果用**顺序方式存储**，则结点之间有如下关系：

- 若 **i** 为结点编号则 如果i>1，则其**父结点**的编号为 **[i/2]**，[i/2]是往下取整的；
- 如果 **2i<=N**，则其**左儿子**（即左子树的根结点）的**编号为 2i**；若 2i>N，则无左儿子；
- 如果 **2i+1<=N**，则其**右儿子**的结点编号为**2i+1**；若 2i+1>N，则无右儿子。
  



### 链式存储与周游



**定义结点结构：**

```cpp
//结点的结构
struct Node
{
    //每个结点的数据
    int data;
    //左子树
    Node * lchild;
    //右孩子
    Node * rchild;
}Tree,*BitTree;
```



**初始化：**

```cpp
BitTree createLink()
{
	int data;
	BitTree T;
	
	cin>>data;		//	输入数据

	T = (BitTree)malloc(sizeof(Node));			//		分配内存空间
	T->data = data;								//		把当前输入的数据存入当前节点指针的数据域中	
	T->lchild = createLink();					//		递归创建左子树		
	T->rchild = createLink();					//		到上一级节点的右边递归创建左右子树
	return T;							//		返回根节点
}
```



**先序遍历：**

```cpp
//	先序遍历
void Preorder(BitTree T)	//		先序遍历二叉树
{
	if(T)
	{	
    if(T->data!='#') cout<< T->data ; // 根
	Preorder(T->lchild);	 //	递归遍历左子树
	Preorder(T->rchild);	//	递归遍历右子树
	}

}
```



**中序遍历：**

```cpp
void Inorder(BitTree  T)
{
    if(T)
    {
        Inorder(T->lchild); //递归遍历左子树    
        if(T->data!='#') cout<<T->data ;       //访问根结点
        Inorder(T->rchild); //递归遍历右子树
    }
}
```



**后序遍历：**

```cpp
void Postorder(BitTree T)
{
    if(T)
    {
        Postorder(T->lchild); //递归遍历左子树 
        Postorder(T->rchild); //递归遍历右子树
        if(T->data!='#') cout<<T->data ; //访问根结点
    }
}
```



**非递归实现：**

思路：

- 使用栈 
- 循环条件是：结点不为空或者栈不为空。
- 先把根结点加入桟中，然后，遍历左子树，当左子树遍历完后，栈顶元素为刚刚的根结点，然后，让根结点出栈，遍历右子树

```cpp
void Preorder(BitTree  T)   
{
    stack<BitTree> s;
    BitTree p=T;
    //栈不为空或者T不为空时，循环继续
    while(p || !s.empty())
    {
        if(p!=NULL)  
        {
            s.push(p); //根结点入栈
            if(p->data!='#')   cout<<p->lchild;  //访问根结点
            p=p->lchild; //先遍历左子树
        }
        else
        {
            p=s.top(); //根结点出栈
            s.pop();   
            p=p->rchild;//遍历右子树
        }
    }
}
```































































































































































































































