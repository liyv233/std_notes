在线性表中，每个数据元素只有一个直接前驱和一个直接后继。

在树形结构中，数据元素之间有着明显的层次关系，并且每一层上的数据元素可能和下一层中多个元素相关，但只能和上一层中一个元素相关。

在图形结构中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。

**图的定义：**

- 图是由顶点集合以及顶点间的关系集合组成的一种数据结构。
- Graph = (V,E) V是顶点的集合；E是边集合（顶点之间关系。

**图的分类：**

- 有向图：顶点对<x,y>是有序的；

- 无向图：顶点对<x,y>是无序的。
- 完全图：若有n个顶点的无向图有n(n-1)/2 条边, 则此图为完全无向图

​						若有n个顶点的有向图有n(n-1)条边, 则此图为完全无向图。

- 连通图：对于图中任意两个顶点都是连通的
- 简单图：无重复的边或顶点到自身的边

**图的基本概念：**

- 无向图顶点的边数叫做度，有向图顶点分为入度和出度。
- 有向的连通图称为强连通图
- 路径长度：路径上边的数目
- 有向树：一个顶点的入度为0、其余顶点的入度均为1的有向图，称为有向树。

**图的顶点与边之间的关系：**

- 顶点的度：顶点关联边的数目
- 有向图的度：出度，入度之和
- 无向图的全部顶点的度的和等于边数的2倍，因为每条边和两个顶点相关联
- 有向图的全部顶点的入度之和与出度之和相等，并且等于边数



## 图的存储结构

图的结构比价复杂，任意两个顶点之间都可能存在关系，不能用简单的顺序存储结构来表示。

如果运用多重链表，即一个数据域多个指针域组成的结点表示图中一个结点，则造成大量存储单元浪费。



### 图的邻接矩阵表示

图的邻接矩阵存储方式是用两个数组来表示图。

一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息。

**无向图邻接矩阵特点：**

- 无向图的邻接矩阵一定是一个**对称矩阵** ， 因此，在实际存储邻接矩阵时只需存储上(或下)三角矩阵的元素
- 对于无向图，邻接矩阵的第i 行(或第i 列)非零元素(或非∞元素)的个数正好是第 i 个顶点的度
- 求顶点vi的所有邻接点就是将矩阵中第i行元素扫描一遍，A[i] [ j]为 1就是邻接点

**有向图邻接矩阵特点：**

- 主对角线上数值依然为0。但矩阵并不对称
- 有向图讲究入度与出度  ， 顶点 vi 的入度：第 i 列 1之和 ， 顶点 vi 的出度：第 i 行 1之和
- 与有向图一样，判断顶点 vi 到 vj 是否存在弧 ， 只需要判断 A[i] [ j] 是否为 1

对于带权图而言,若顶点 vi ， vj 之间有边相连，则邻接矩阵中对应项存放着该边对应的权值

注意:

- 在简单应用中，可直接用二维数组作为图的邻接矩阵(顶点信息等均可省略)。
- 无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可采用压缩存储。
- 邻接矩阵表示法的空间复杂度为O ( n 2 )  其中n为图的顶点数
- 用邻接矩阵法存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。
-  稠密图适合使用邻接矩阵的存储表示。


**结点定义：**

~~~cpp
#define MaxVertexNum 100	//顶点数目的最大值
typedef char VertexType;	//顶点的数据类型
typedef int dataType;	//带权图中边上权值的数据类型
typedef struct{
	VertexType Vex[MaxVertexNum];	//顶点表
	dataType Edge[MaxVertexNum][MaxVertexNum];	//邻接矩阵，边表
	int vexnum, arcnum;	//图的当前顶点数和弧树
}MGraph;

~~~



### 图的邻接表表示

当一个图为稀疏图时（边数相对顶点较少），使用邻接矩阵法浪费大量的存储空间

图的邻接表法结合了顺序存储和链式存储方法，大大减少了这种不必要的浪费。

所谓邻接表，是指对图G中的每个顶点v i，建立一个单链表，第 i 个单链表中的结点表示依附于顶点 vi 的边,(对于有向图则是以顶点vi为尾的弧) .这个单链表就称为顶点 vi 的边表(对于有向图则称为出边表)

边表的头指针和顶点的数据信息采用顺序存储(称为顶点表)，所以在邻接表中存在两种结点:顶点表结点和边表结点，

**顶点表结点由 顶点域(data)和指向第一条邻接边的指针(firstarc) 构成，边表(邻接表)结点由邻接点域(end)和指向下一条邻接边的指针域(nextarc) 构成。**

对于带权值的图，可以在**边表**结点定义中再增加一个weight的数据域，存储权值信息即可。

**图的邻接表存储结构定义：**

~~~cpp
#define MAXVEX 100	//图中顶点数目的最大值
type char VertexType;	//顶点类型
typedef int dataType;	//边上的权值类型

/*边表结点*/
typedef struct EdgeNode{
	int end;	//该弧所指向的顶点的下标或者位置
	dataType weight;	//权值，对于非网图可以不需要
	struct EdgeNode *next;	//指向下一个邻接点
}EdgeNode;

/*顶点表结点*/
typedef struct VertexNode{
	Vertex data;	//顶点域，存储顶点信息
	EdgeNode *firstedge	//边表头指针
}VertexNode, AdjList[MAXVEX];

/*邻接表*/
typedef struct{
	AdjList adjList;
	int numVertexes, numEdges;	//图中当前顶点数和边数
}

~~~



图的邻接表存储方法特点:

- 若G为无向图，则所需的存储空间为 v + 2e；若G为有向图,则所需的存储空间为 v + e。

- 在邻接表中，对于顶点 vi ，若要找出它的所有邻边，只需要读取它的邻接表。

  在邻接矩阵中，对于顶点 vi ，若要找出它的所有邻边，需要检查 第 i 行所有A[i] [ j] ，花费的时间为 n 

- 确定给定的两个顶点间是否存在边，在邻接矩阵中检查 A[i] [ j] 的值即可，

  在邻接表中则需要在相应结点对应的边表中查找另一结点，效率较低。

- 在有向图的邻接表表示中，求 vi 的出度只需计算其邻接表中的结点个数；但求 vi 的入度则需要遍历全部的邻接表,找到所有出度存在 vi 的顶点





## 图的遍历



### 广度优先周游

**思想：**

- 1：从指定顶点 vi 出发，先访问 vi 并将其标志以访问
- 2：依次访问 vi 的所有邻接点 vj,vk...

**算法复杂度分析：**

- 无论是邻接表还是邻接矩阵的存储方式，BFS 算法都需要借助一个辅助队列Q, n个顶点均需入队一次，在最坏的情况下，空间复杂度为 ov
- 采用邻接表存储方式时，每个顶点均需搜索一次(或入队一次)， 在搜索任一顶点的邻接点时，每条边至少访问一次，算法总的时间复杂度为 ov+e
- 采用邻接矩阵存储方式时，查找每个顶点的邻接点所需的时间为 ov ， 故算法总的时间复杂度为 ov2



图的邻接矩阵表示是唯一的，但对于邻接表来说，若边的输入次序不同，生成的邻接表也不同。因此，对于同样一个图，基于邻接矩阵的遍历所得到的DFS序列和BFS序列是唯一的，基于邻接表的遍历所得到的DFS序列和BFS序列是不唯一的。

~~~cpp
/*邻接矩阵的广度遍历算法*/
void BFSTraverse(MGraph G){
	int i, j;
	Queue Q;
	for(i = 0; i<G,numVertexes; i++){
		visited[i] = FALSE;
	}
	InitQueue(&Q);	//初始化一辅助用的队列
	for(i=0; i<G.numVertexes; i++){
		//若是未访问过就处理
		if(!visited[i]){
			vivited[i] = TRUE;	//设置当前访问过
			visit(i);	//访问顶点
			EnQueue(&Q, i);	//将此顶点入队列
			//若当前队列不为空
			while(!QueueEmpty(Q)){
				DeQueue(&Q, &i);	//顶点i出队列
				//FirstNeighbor(G,v):求图G中顶点v的第一个邻接点，若有则返回顶点号，否则返回-1。
				//NextNeighbor(G,v,w):假设图G中顶点w是顶点v的一个邻接点，返回除w外顶点v
				for(j=FirstNeighbor(G, i); j>=0; j=NextNeighbor(G, i, j)){
					//检验i的所有邻接点
					if(!visited[j]){
						visit(j);	//访问顶点j
						visited[j] = TRUE;	//访问标记
						EnQueue(Q, j);	//顶点j入队列
					}
				}
			}
		}
	}
}

~~~



### 深度优先周游









## 最小生成树

**图的生成树：**连通图的生成树是一个含有图中全部的顶点，n − 1 条边，是一个连通图

**最小生成树：**边的权值之和最小的生成树

最小生成树可能有多个，但边的权值之和总是唯一且最小的



### Prim算法

prim算法基于贪心，我们每次总是选出一个离生成树距离最小的点去加入生成树顶点集合，最后实现最小生成树

**算法实现：**

- 1：构建一个长度为 顶点数 的一维数组存储最短距离
- 2：初始话生成树顶点集合 T，此时集 T 中只有起始顶点 v0 ；
- 3：选取距离 起始顶点 v0 距离最近的点 加入 T，根据 T 更新 dist













