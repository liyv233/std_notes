# 插入排序



## 直接插入



- 1：从第一个元素开始，该元素可以认为已经被排序
- 2：取下一个元素为 item ，与前面已排序的元素序列从后往前对比 
  - 如果已排序序列存在大于(小于)item，则将该元素移到下一位,item则相应往前移动
- 3：重复步骤2，直到找到已排序元素中小于(大于)等于item的元素
- 4：将 item 插入到该元素的后面，如果已排序所有元素都大于item，则将item插入到开始的位置
- 重复步骤 ， 直到完成排序

```cpp
void InsertSort(int* arr, int n)
{
	for (int i = 0; i < n - 1; ++i)
	{
		//记录有序序列最后一个元素的下标
		int end = i;
		//待插入的元素
		int item = arr[end + 1];
		//单趟排
		while (end >= 0)
		{
			//比插入的数大就向后移
			if (item < arr[end])
			{
				arr[end + 1] = arr[end];
				end--;
			}
			//比插入的数小，跳出循环
			else
			{
				break;
			}
		}
		//tem放到比插入的数小的数的后面
		arr[end  + 1] = item;
		//代码执行到此位置有两种情况:
		//1.待插入元素找到应插入位置（break跳出循环到此）
		//2.待插入元素比当前有序序列中的所有元素都小（while循环结束后到此）
	}
}

```



- 时间复杂度
  - 最坏情况下为O(N^2)，此时待排序列为逆序，或者说接近逆序
  - 最好情况下为O(N)，此时待排序列为升序，或者说接近升序
- 空间复杂度：O(1)



## 二分插入

二分插入排序法：由于在 直接插入排序 过程中，待插入数据左边的序列总是有序的，针对有序序列，可以使用 二分法 去插入数据。适用于数据量比较大的情况。

算法思想：

- 1：取下一个元素为 item ，有序区间内进行折半查找，找到插入位置
- 2：从后往前移动元素，将待排序的元素插入序列中

```cpp
#include<stdio.h>
 
void BinInsertSort(int A[],int n)
{
	int i,j;
 
	for(i = 1;i < n;i++)
	{
		int get = A[i];//取得的待排新元素
		int left = 0;
		int right = i-1;//已排序的有序区间
		
		while(left <= right)//有序区间内进行折半查找，找到插入位置
		{
			int mid = (right+left)/2;
			if(A[mid] > get)
				right = mid - 1;
			else
				left = mid + 1;
		}
		for(j = i - 1;j >= left;j--)//移出位置
		{
			A[j+1] = A[j];
		}
		A[left] = get;//将待排元素插入
	}
}
 
int main()
{
	int i;
	int A[] = {5,3,56,23,12,67,25};
	int n = sizeof(A)/sizeof(A[0]);
 
	BinInsertSort(A,n);
 
	for(i = 0;i < n;i++)
	{
		printf("%-6d",A[i]);
	}
	printf("\n");
	return;
}
```

- 相比于直接插入排序，二分插入排序只是减少了元素比较的次数，并未减少元素移动的次数，本质上讲，并未提高算法的性能。





## 表插入排序

表插入排序：把待排序的数组放入静态链表中，通过修改链表中的索引域的值来给出排序结果

特点：

- 不改变原数组中元素的位置，只是在索引域中给出其在排序表中位置
- 相比较于直接插入排序算法，不需要移动元素

算法实现：

- 1：创建静态链表，下标为0的位置存储 数组最大长度 ，arr[0].next 永远存储最小元素的下标
- 2：将数组中第一个数存入链表，其为当前链表最大的元素，下标为1，所以arr[0].next 为 1 ， 该元素.next 为 0 ，表示其为当前静态数组最大的元素
- 3：取下一个元素 item 存入静态链表下标为 2 的位置，更新 静态链表的 next 下标 
  - arr[0].next 指向最小元素的下标 ， arr[下标].next  指向的元素下标由低到高
- 4：归位，p指向链表中当前需要归位的元素，q指向链表中当前需要归位的元素的下一个元素
- 5：p指向的元素和位置i的元素互换之后，此时 i 指向的记录的 n e x t 值应设为p。对于当前的i，表明1 − > ( i − 1 ) 1->(i-1)1−>(i−1)个较小的元素已经归位完毕，如果此时发现当前的p < i ，则应顺着p的 next 值找到 p>=i 的p值，因为前 1 − > ( i − 1 )  的元素已经归位好了，不应该再去移动它们

```cpp
#define MY_MAXIMUM 1000000
#define TABLE_SIZE 10

/* Function to print an array */
void printArray(int arr[], int size)
{
	int i;
	for (i = 0; i < size; i++)
		cout << arr[i] << " ";
	cout << endl;
}

typedef struct
{
	int data;
	int next;
}SLNode;

void tableSort(int arr[],int n)
{
	SLNode table[TABLE_SIZE];
	table[0].data = MY_MAXIMUM;
	table[0].next = 1;
	table[1].next = 0;
	int p = 0;
	int q = 0;


	for (int k = 0; k < n; k++)
	{
		table[k+1].data = arr[k];
	}
	//对初始列表进行排序（）只是改变其对应的next域的指针值
	for (int i = 1; i < n; i++)
	{
		int currentIndex = table[0].next;
		int preIndex = table[0].next;
		int j = 0;
		for (;j<i;j++)
		{
			if (table[currentIndex].data < arr[i])
			{
				preIndex = currentIndex;
				currentIndex = table[currentIndex].next;
			}
			else
				break;
		}
		if (j == i)//如果待插入的元素大于有序序列的最大的元素
		{
			table[i+1].next = 0;
			table[preIndex].next = i+1;
		}
		else if (j==0)//如果待插入的元素小于有序序列的最小的元素
		{
			table[i + 1].next = currentIndex;
			table[0].next = i+1;
		}
		else//如果待插入的元素位于有序序列最小元素和最大元素之间
		{
			table[i + 1].next = currentIndex;
			table[preIndex].next = i + 1;
		}
	}
	//根据已经排好序的序列的元素的next域的指针值将元素放到正确的位置
	p = table[0].next;
	q = 0;
	for (int i=1;i<n;i++)
	{
		while (p < i)
		{
			p= table[p].next;
		}
		q= table[p].next;
		if (p!=i)
		{
			int tempData= table[p].data;
			int tempNext = table[p].next;
			table[p].data= table[i].data;
			table[p].next = table[i].next;
			table[i].data = tempData;
			table[i].next = p;
		}
		p = q;
	}
	for (int i=0;i<n;i++)
	{
		arr[i] = table[i + 1].data;
	}
	return;
}

```





# Shell 排序

- 1：先选定一个小于N的整数gap作为第一增量，然后将所有距离为gap的元素分在同一组，并对每一组的元素使用直接插入排序
- 2：再取一个比第一增量小的整数作为第二增量，重复 1 操作…
- 3：当增量的大小减到1时，就相当于整个序列被分到一组，进行一次直接插入排序，排序完成



```cpp
//希尔排序
void ShellSort(int* arr, int n)
{
	int gap = n;
	while (gap>1)
	{
		//每次对gap折半操作
		gap = gap / 2;
		//单趟排序
		for (int i = 0; i < n - gap; ++i)
		{
			int end = i;
			int tem = arr[end + gap];
			while (end >= 0)
			{
				if (tem < arr[end])
				{
					arr[end + gap] = arr[end];
					end -= gap;
				}
				else
				{
					break;
				}
			}
			arr[end + gap] = tem;
		}
	}
}

```



- 时间复杂度平均：O(N^1.3)
  空间复杂度：O(1)

链表实现

```cpp
#include <stdio.h>
#include <stdlib.h>

/*数据结构定义*/
typedef int DataType;
typedef struct
{
  DataType *data; //用于存放待排序关键字的起始地址
  int NUM; //待排序关键字的个数 
} SortObject;

typedef struct node //用于表插入排序的数据结构
{
  DataType  info;  
  struct node *next;  
} linkObject;

//输出顺序表
void print(SortObject *p)
{
 for(int i=0;i<p->NUM;i++)
   printf("%d ",p->data[i]);
 printf("\n");  
}

//输出链表
void printLink(linkObject *Head)
{
  linkObject *p = Head->next ;
  while(p)
  {
    printf("%d ",p->info);
    p = p->next;
  }
   printf("\n");
}


/* 第四关
此处请填写代码实现递增序进行shell排序,
  
  要求每趟排序后 调用print函数，输出关键字的排列情况
  */
void shellSort( SortObject *Rec,int d )
{
  int i,j,inc;
  DataType temp;
  for(inc=d;inc>0;inc/=2)
  {
    for(i=inc;i<Rec->NUM;i++)
    {
      temp=Rec->data[i];
      for(j=i-inc;j>=0 && temp<Rec->data[j];j-=inc)
        Rec->data[j+inc]=Rec->data[j];
      Rec->data[j+inc]=temp;
    }
    print(Rec);
  }
}

}
```



# 选择排序

- 不稳定
- 选择排序的时间复杂度为 on2
- 适用场景：待排序序列中，元素个数较少时。



## 直接选择排序

基本思想：第一次从待排序的数据元素中选出最小（最大）的元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素

优化：在一趟遍历中，同时找出最大值与最小值，放到数组两端，这样就能将遍历的趟数减少一半。

```cpp
        /*初始化左端、右端元素索引*/
	    int left = 0;
	    int right = len - 1;
	    while (left < right){
	    	/*初始化最小值、最大值元素的索引*/
	        int min = left;
	        int max = right;
	        for (int i = left; i <= right; i++){
	        	/*标记每趟比较中最大值和最小值的元素对应的索引min、max*/
	            if (arr[i] < arr[min])
	                min = i;
	            if (arr[i] > arr[max])
	                max = i;
	        }
	        /*最大值放在最右端*/
	        int temp = arr[max];
	        arr[max] = arr[right];
	        arr[right] = temp;
	        /*此处是先排最大值的位置，所以得考虑最小值（arr[min]）在最大位置（right）的情况*/
	        if (min == right)
	            min = max;
	        /*最小值放在最左端*/
	        temp = arr[min];
	        arr[min] = arr[left];
	        arr[left] = temp;
	        /*每趟遍历，元素总个数减少2，左右端各减少1，left和right索引分别向内移动1*/
	        left++;
	        right--;
	    }

```



## 堆排序(未完成)

堆排序就要用到前面学到的数据结构二叉树的知识了。堆的作用是什么呢?就是寻找最值。所以根节点肯定最大（大堆）或者最小（小堆）。我们把根节点和最后一个结点进行交换，数组最后一个数肯定就是最大或者最小的。最后又在剩下的数据里面建堆。 要注意的是升序建大堆，降序建小堆

```
//C语言
//向下调整
void Adjust_down(int arr[], int size, int root)
{
	while (1)
	{
		int left = root * 2 + 1;
		int right = root * 2 + 2;
		int min = left;//最小的为最左孩子
		if (left >= size)//没有孩子结点
		{
			return;
		}
		if (right < size && arr[right] < arr[left])//有右孩子
		{
			min = right;
		}
		if (arr[root] <= arr[min])//根节点已经是最小
		{
			return;
		}
		int temp = arr[root];
		arr[root] = arr[min];
		arr[min] = temp;
		root = min;
	}
}
	//建堆
void CreateBigHeap(int arr[], int size)
{
	//对左子树建堆，再对右子树建堆
	int notlevel = (size - 2) / 2;//从最后一个非叶子结点开始调整
	while (notlevel >= 0)
	{
		Adjust_down(arr, size, notlevel);
		--notlevel;
	}
}
void HeapSort(int arr[], int size)
{
	//建堆
	CreateBigHeap(arr, size);
 
	for (int temp = 1; temp < size; ++temp)
	{
		int t = arr[0];
		arr[0] = arr[size - temp]; //这个值就是最后一个叶子结点。
		arr[size - temp] = t;	
		Adjust_down(arr, size-temp,0);//从根节点开始调整
	}
}
```



# 交换排序



## 冒泡排序

**基本原理：**

- 第一层循环：每一趟只能确定将一个数归位，如果有 n 个数进行排序，只需将 n-1 个数归位，也就是要进行 n-1 趟操作。
- 第二层循环：比较相邻的元素，如果前一个比后一个大，就交换他们两个

**时间复杂度**：on2 （min：on ， max：on2）

**空间复杂度：**o1

```cpp
 void bubbleSort(){
        int sortArr[] = {10,1,2,4,6,7,8,9,3,5};
         //对 n-1 个数进行冒泡
        for (int i = 0; i < sortArr.length - 1; i++) {
            for (int j = 0; j < sortArr.length - 1 - i; j++) {
                // sortArr.length - 1 - i 以后的数已经排好序
                if (sortArr[j] > sortArr[j + 1]) {
                    int temp = sortArr[j];
                    sortArr[j] = sortArr[j + 1];
                    sortArr[j + 1] = temp;
                }
            }
        }
    }

```



## 快速排序

**基本原理：**

- 1：每趟排序时选出一个基准值，然后将所有元素与该基准值比较，并按大小分成左右两堆
  - 从两端开始”探测”，先从右往左找一个小于基准值的数，再从左往右找一个大于基准值的数，然后交换他们。
  - 相遇时，交换 arr[基准] ， arr[相遇]
- 2：递归执行 1 ，直到区间的size为 0 或者 1（分治算法

**时间复杂度：**

- 最坏情况下：即每次都是相邻的两个数进行交换，此时时间复杂度为 on2
- 平均时间复杂度：nlogn

```cpp
void QuickSort(int *arr, int begin, int end){
    if(begin > end)
        return;
    int tmp = arr[begin];
    int i = begin;
    int j = end;
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        if(i<j)
            a[i++]=a[j];
        while(arr[i] <= tmp && j > i)
            i++;
        if(i<j)
            a[j--]=a[i];
    }
    // 相遇时，交换 arr[基准] ， arr[相遇]
    arr[i] = tmp;
    // 对基准左边 执行上述操作
    Quick_Sort(arr, begin, i-1);
     // 对基准右边 执行上述操作
    Quick_Sort(arr, i+1, end);
}

```



## 归并排序（未完成）

 归并排序也需要借助分治算法。但是这个的基准值是一直是数组的中间那个数，而不是像快速排序一样选边上的数据作为基准值。

**时间复杂度：** 数列分割：logn  *  数列归并：on  = nlogn

- 对两个有序序列合并：比较二个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可

```cpp
#include<bits/stdc++.h>
using namespace std;
void mergearray(int a[],int first,int mid,int last,int temp[])	//将两个有序数组合并排序 
{
	int i=first,j=mid+1;
	int m=mid,n=last;
	int k=0;
	while(i<=m&&j<=n)
	{
		if(a[i]<a[j])
			temp[k++]=a[i++];
		else
			temp[k++]=a[j++];
	}
	while(i<=m)
		temp[k++]=a[i++];
	while(j<=n)
		temp[k++]=a[j++];
	for(i=0;i<k;i++)
		a[first+i]=temp[i];
}
 
void mergesort(int a[],int first,int last,int temp[])	//将两个任意数组合并排序 
{
	if(first<last)
	{
		int mid=(first+last)/2;
		mergesort(a,first,mid,temp);	//左边有序 
		mergesort(a,mid+1,last,temp);	//右边有序 
		mergearray(a,first,mid,last,temp);	//再将两个有序数组合并 
	}
}
 
bool MergeSort(int a[], int n)  
{  
    int *p = new int[n];  //分配一个有n个int型元素的数组所占空间，并将该数组的第一个元素的地址赋给int *型指针p。
    if (p == NULL)  
        return false;  
    mergesort(a, 0, n - 1, p);  
    delete[] p;  
    return true;  
} 

int main()
{
	int a[1005];
	int n;
	scanf("%d",&n);
	for(int i=0;i<n;i++)
		scanf("%d",&a[i]);
	MergeSort(a,n);
	for(int i=0;i<n;i++)
		printf("%d ",a[i]);

}

```



























































































































































































































